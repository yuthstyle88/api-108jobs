name: Build & Deploy Rust App

on:
  push:
    branches: ["prod", "dev"]
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      # Constant Rust binary name (as defined in Cargo.toml [[bin]])
      BIN_NAME: app_108jobs_api_server
      # Current branch name (prod/dev)
      BRANCH: ${{ github.ref_name }}
      # Service name per-branch (adjust if you use a single prod service)
      SERVICE_NAME: ${{ github.ref_name == 'prod' && 'app-108jobs-api-server' || 'staging-app-108jobs-api-server' }}
      # Target app path on remote (one path for both branches; change if you want per-branch paths)
      APP_PATH: ${{ github.ref_name == 'prod' && '/var/www/apps/108jobs-api-server' || '/var/www/apps/108jobs-api-server-dev' }}
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ” Setup SSH
        uses: webfactory/ssh-agent@v0.9.1
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: ðŸ—ï¸ Add SSH host key to known_hosts
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          ssh-keyscan -p "${{ secrets.SSH_PORT }}" "${{ secrets.SSH_HOST }}" >> ~/.ssh/known_hosts

      - name: ðŸš€ Build & Deploy (branch-aware, safe quoting)
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${{ env.BRANCH }}"
          BIN_NAME="${{ env.BIN_NAME }}"
          OUT_NAME="${BIN_NAME}"
          APP_PATH="${{ env.APP_PATH }}"
          SERVICE_NAME="${{ env.SERVICE_NAME }}"

          echo "Local â†’ BRANCH=${BRANCH}, BIN_NAME=${BIN_NAME}, OUT_NAME=${OUT_NAME}"
          echo "Remote â†’ ${APP_PATH}, service=${SERVICE_NAME}"

          ssh -p "${{ secrets.SSH_PORT }}" "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" bash -s -- "$BRANCH" "$BIN_NAME" "$OUT_NAME" "$APP_PATH" "$SERVICE_NAME" <<'REMOTE'
          set -euo pipefail
          BRANCH="$1"
          BIN_NAME="$2"
          OUT_NAME="$3"
          APP_PATH="$4"
          SERVICE_NAME="$5"

          echo "Remote: BRANCH=${BRANCH}, BIN=${BIN_NAME}, OUT=${OUT_NAME}, APP_PATH=${APP_PATH}"

          # Ensure app path and git repo
          mkdir -p "$APP_PATH"
          cd "$APP_PATH"

          # Mitigate 'safe.directory' issues if repo owner != current user
          git config --global --add safe.directory "$APP_PATH" || true

          if [ ! -d .git ]; then
            echo "Clone fresh: branch ${BRANCH}"
            git clone -b "$BRANCH" git@github.com:yuthstyle88/fast-work-new.git .
          else
            echo "Fetch & checkout ${BRANCH}"
            git fetch --all --prune
            git checkout "$BRANCH"
            git pull --ff-only origin "$BRANCH"
          fi
          
          echo "Checking for migration changes since last commit..."
          if git diff --name-only HEAD@{1} HEAD | grep -q '^migrations/'; then
            echo "ðŸ§¹ Migrations changed â†’ running cargo clean"
            cargo clean
          else
            echo "âœ… No migration changes â†’ skipping cargo clean"
          fi

          echo "Build release binary: ${BIN_NAME}"
          cargo build --release --bin "$BIN_NAME"
    
          sudo -n -l | head -n 20 || true
          
          # Stop service before replacing binary to avoid in-use file issues (no fallbacks)
          if [ "$BRANCH" = "prod" ] || [ "$BRANCH" = "dev" ]; then
            echo "Stopping systemd service: ${SERVICE_NAME}"
            sudo  -n systemctl stop "${SERVICE_NAME}.service" || true

            echo "Waiting up to 20s for ${SERVICE_NAME} to stop..."
            for i in {1..20}; do
              if sudo -n systemctl is-active --quiet "${SERVICE_NAME}.service" 2>/dev/null; then
                sleep 1
              else
                echo "${SERVICE_NAME} stopped."
                break
              fi
            done
          fi

          echo "Install binary â†’ ${APP_PATH}/${OUT_NAME}"
          cp "target/release/${BIN_NAME}" "${APP_PATH}/${OUT_NAME}"
          chmod 775 "${APP_PATH}/${OUT_NAME}"

          # Prepare .env files
          [ -f .env ] || install -m 640 /dev/null .env || true

          # Start systemd service for prod and dev branches (no fallbacks)
          if [ "$BRANCH" = "prod" ] || [ "$BRANCH" = "dev" ]; then
            echo "Starting systemd service: ${SERVICE_NAME}"
            # Reload units then start (run as deploy; NOPASSWD is guaranteed for this user)
            sudo -n systemctl start "${SERVICE_NAME}.service" || true
          else
            echo "Branch ${BRANCH}: skip systemd start"
          fi
          REMOTE
